(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{294:function(e,n,s){"use strict";s.r(n);var t=s(3),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"webpack-基础知识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack-基础知识"}},[e._v("#")]),e._v(" webpack 基础知识")]),e._v(" "),s("p",[e._v("1、前端工程化")]),e._v(" "),s("p",[s("em",[s("strong",[e._v("我对前端工程化的理解")])])]),e._v(" "),s("p",[e._v("参考维基百科对软件工程的定义：将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中。\n故名思议，前端工程化也就是将系统化的、规范的、可度量的方法用于前端的开发、运行和维护的过程。可以简单的理解成系统化，模块化，规范化的过程。\n现如今，webApp业务日益复杂化和多元化，前端开发已经由以WebPage模式为主转变为以WebApp模式为主了。现在随便找个前端项目，都已经不是过去的拼个页面+搞几个jQuery插件就能完成的了。\n工程复杂了就会产生许多问题，比如：如何进行高效的多人协作？如何保证项目的可维护性？如何提高项目的开发质量？...等等一系列的工程化问题，前端工程化就是为了解决这些工程问题，提高\n整个系统生产效率。")]),e._v(" "),s("ul",[s("li",[e._v("工程化是系统化、模块化、规范化的过程；")]),e._v(" "),s("li",[e._v("工程化主要解决“如何提高整个系统生产效率”的问题")])]),e._v(" "),s("p",[e._v("前端工程化的主要改变在哪些方面")]),e._v(" "),s("ul",[s("li",[e._v("工具：需要用到更多的自动化机械，更多的脚手架")]),e._v(" "),s("li",[e._v("人员：协作的人开始变得更多，需要有一定的机制保障合作的顺畅")]),e._v(" "),s("li",[e._v("编写代码方式：大量的用到预制模版，用组件化的方式写项目")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("2、webpack主要功能")]),e._v(" "),s("ul",[s("li",[e._v("编译：JavaScript，css编译")]),e._v(" "),s("li",[e._v("文件的压缩，打包，合并，公共模块提取等")]),e._v(" "),s("li",[e._v("图片等资源的处理如压缩图片、合并雪碧图")]),e._v(" "),s("li",[e._v("Tree-shaking等优化JavaScript工具")]),e._v(" "),s("li",[e._v("webpack-dev-server，eslint，热更新等帮助开发的工具")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("3、webpack 安装")]),e._v(" "),s("ul",[s("li",[e._v("安装node")]),e._v(" "),s("li",[e._v("全局安装 npm install webpack -g;(webpack4.0还需要全局安装webpack-cli)")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("4、webpack 核心概念和基础使用")]),e._v(" "),s("ol",[s("li",[e._v("webpack配置文件 webpack.config.js 的重要性")])]),e._v(" "),s("pre",[s("code",[e._v("- 配置文件是webpack打包的依据，webpack如何打包，打包成什么样，全都由配置文件来指定\n- 对于webpack，我们的主要工作也是编写、修改webpack的配置文件\n- webcpack配置文件的核心概念：Entry和Output，loader，plugin\n")])]),e._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[e._v("webcpack配置文件的核心概念：Entry和Output，loader，plugin的理解")])]),e._v(" "),s("pre",[s("code",[e._v("- Entry：Entry是webpack的打包入口：代码从这里开始编译，程序开始的起点\n- Output: Output是webpack打包的出口：最终的打包结果会根据output的定义输出，会影响到资源的路径\n\n    module.exports = {\n      //entry:'./app.js',\n      //entry:['./app.js','./app2.js'], // 将两个入口文件打包成一个入口文件\n    \n      // 将入口文件打包成多个入口文件\n      entry: {\n          app111: './app.js',\n          app222: \"./app2.js\",\n      },\n      output: {\n          path: __dirname + '/src/mybundle', // 指定打包的文件夹\n          filename: './js/[name].[hash:6].js'  // 指定打包后文件存放的文件夹和打包后问价的名字\n      },\n      // 打包规则，编译规则\n      module: {\n          // 打包规则，编译规则\n          rules: [\n            {\n                test: /\\.js$/, // 匹配js的文件\n                use: [\n                  {\n                      loader: 'babel-loader', // 编译es6\n                      option: {}, // loader的配置项 // loader的顺序是从后往前执行\n                  }\n                ]\n            }\n          ]\n      }\n    }\n\n- plugin：webpack插件plugin是webpack的额外扩展：一些插件式的额外功能由plugin定义，帮助webpack优化代码，提供功能；plugin有的是webpack自带的，有的需要额外安装\n")])]),e._v(" "),s("p",[e._v("3.常用的loader列举，loader 是 对某种类型的文件的解析，loader的顺序是从下往上加载的")]),e._v(" "),s("pre",[s("code",[e._v("- css：css-loader,style-loader 等css处理loader\n- url-loader,image-loader 等图片字体文件等资源的处理loader\n- less-loader,sass-loader,babel-loader 等编译的loader\n- 语法糖的loader，比如vue-loader\n")])]),e._v(" "),s("p",[e._v("4.常用的plugin列举")]),e._v(" "),s("pre",[s("code",[e._v("- commonsChunkPlugin:提取公共模块，uglifyjsWebpackPlugin:减少js体积，PurifyCSS:优化css体积；\n- HtmlWepackPlugin:把打包结果再打包一个html，把打包结果自动的引入该html中;HotModuleReplagementPlugin：热更新插件\n")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("5、用webpack开始一次打包")]),e._v(" "),s("p",[s("em",[s("strong",[e._v("直接指定出口与入口")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("webpack-cli --entry <entry> --output <output>\n")])])]),s("p",[s("em",[s("strong",[e._v("通过配置文件打包")])])]),e._v(" "),s("p",[e._v("不指定配置文件名打包：直接在命令行输入webpack")]),e._v(" "),s("p",[e._v("指定配置文件名打包：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("webpack --config <configfile>\n")])])]),s("p",[s("em",[s("strong",[e._v("全局webpack和局部webpack")])])]),e._v(" "),s("pre",[s("code",[e._v("- 全局webpack：通过-g安装的webpack为全局webpack，可以在命令行里直接输入webpack命令的为全局webpack\n- 局部webpack：在项目文件夹下安装的webpack，即安装在项目文件夹里的node_modules里；局部webpack的作用：当我们的项目需求的webpack版本和我们全局的webpack版本不一致时，就需要安装局部的webpack\n- 安装局部webpack：npm installwebpack --save-dev\n- 使用局部webpack打包：通过在package.json script 增加一个命令，build：webpack ，在命令行里通过 使用 npm run build ，可以优先使用局部webpack打包\n")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("6、JavaScript的编译")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("编译es6语法： babel-loader, @babel/core （babel-loader是编译es6、es7的语法的） ，babel-preset:储存JavaScript不同标准的插件，通过使用正确的presets，告诉babel按照哪个规则编译；")]),e._v(" "),s("p",[e._v("module.exports = {\nentry: {\napp: './app.js'\n},")]),e._v(" "),s("pre",[s("code",[e._v(" output: {\n     filename: '[name].[hash:8].js'\n },\n module:{\n \trules:[\n \t {\n         /**\n          * 编译js，主要是将es6，es7的语法编译成浏览器支持的es5，\n          * 所需要的loader：babel-loader，@babel/core（用来解析babel-loader的）；\n          * 除了安装上述两个babel的loader之外，还必须安装babel的插件，babel-preset的插件,告诉babel按照哪个规范编译\n          * babel-preset是存储JavaScript不同标准的插件，通过使用正确presets，告诉babel按照哪个规范编译；\n          * presets的常见规范：es2015，es2016,es2017,env(es2015，es2016,es2017以及多种浏览器的支持规范,通常采用),babel-preset-stage\n          *\n          * \n          */\n \t \ttest:/\\.js$/, \n \t \tuse:{\n              loader:'babel-loader',// 需要通过npm安装babel-loader，@babel/core，才能使用babel\n              option:{\n                 presets:[\n                     [\n                         \"@babel/preset-env\", // 需要通过npm 安装@babel/preset-env这个babel插件\n                         {\n                             targets:{\n                                 browsers:[\">1%\"] //配置安装全世界浏览器占有率超过1%的兼容的js打包\n                             }\n                         }\n                     ]\n                 ]\n              }\n \t \t}\n \t },\n \t]\n }\n")])]),e._v(" "),s("p",[e._v("}")])]),e._v(" "),s("li",[s("p",[e._v("编译es6、es7的方法（比如promise等方法，async）：babel-polyfill,babel-plugin-transform-runtime babel-runtime")])])]),e._v(" "),s("p",[s("em",[s("strong",[e._v("babel-polyfill")])])]),e._v(" "),s("pre",[s("code",[e._v('  ```\n    /**\n    * babel只能编译es6、es7的语法，如果要编译es6的方法，则需要用到babel-polyfill\n    * 通过npm 安装 babel-polyfill\n    * 在入口文件里引入babel-polyfill 即可使用\n    * babel-polyfill 的原理：在全局用es5重写了es6的方法；\n    * babel-polyfill缺点会使项目体积增大\n    */\n    import "babel-polyfill"; \n    new Promise(setTimeout(()=>{\n      console.log(1);\n    }));\n    async function a(){\n    \n    }\n  ```\n')])]),e._v(" "),s("p",[s("em",[s("strong",[e._v("babel-plugin-transform-runtime babel-runtime 生效方式")])])]),e._v(" "),s("pre",[s("code",[e._v("```\n  module.exports = {\n      entry: {\n          app: './app.js'\n      },\n  \n      output: {\n          filename: '[name].[hash:8].js'\n      },\n      module:{\n        rules:[\n        {\n              /**\n              * 编译js，主要是将es6，es7的语法编译成浏览器支持的es5，\n              * 所需要的loader：babel-loader，@babel/core（用来解析babel-loader的）；\n              * 除了安装上述两个babel的loader之外，还必须安装babel的插件，babel-preset的插件,告诉babel按照哪个规范编译\n              * babel-preset是存储JavaScript不同标准的插件，通过使用正确presets，告诉babel按照哪个规范编译；\n              * presets的常见规范：es2015，es2016,es2017,env(es2015，es2016,es2017以及多种浏览器的支持规范,通常采用),babel-preset-stage\n              */\n          test:/\\.js$/, \n          use:{\n                  loader:'babel-loader',// 需要通过npm安装babel-loader，@babel/core，才能使用babel\n                  option:{\n                      presets:[\n                          [\n                              \"@babel/preset-env\", // 需要通过npm 安装@babel/preset-env这个babel插件\n                              {\n                                  targets:{\n                                      browsers:[\">1%\"] // 配置全世界浏览器占有率超过1%的兼容的js打包\n                                  }\n                              }\n                          ]\n                      ],\n                      /**\n                      * 对es6的方法的编译：babel-plugin-transform-runtime babel-runtime \n                      * npm 安装 babel-plugin-transform-runtime babel-runtime，\n                      * 注意：babel-plugin-transform-runtime babel-runtime 作为babel的插件，必须跟@babel/core的版本相同\n                      * 如果之前安装@babel/core，则安装runtime时必须安装@babel版本的runtime\n                      * npm install @babel/plugin-transform-runtime @babel/runtime \n                      * babel-plugin-transform-runtime 原理：生成用es5重写es6的局部对象，对没有使用es6到的方法则不会重写；\n                      */\n                      plugins:[\n                          [\n                              \"@babel/transform-runtime\"\n                          ]\n                      ]\n                  }\n          }\n        },\n        ]\n      }\n  }\n```\n")])]),e._v(" "),s("ul",[s("li",[e._v("编译es6、es7的语法糖：装饰器，ts,vue,jsx等等"),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('webpack.config.js\n\n    module.exports = {\n        entry: {\n            app: \'./app.js\'\n        },\n    \n        output: {\n            filename: \'[name].[hash:8].js\'\n        },\n        module:{\n          rules:[\n                \n            /**\n              * 编译es6，es7的语法糖，以ts为列\n              * npm 安装 typescript ts-loader；\n              * 新建一个tsconfig.json 配置文件\n              */\n            {\n                test:/\\.tsx?$/,\n                use:\'ts-loader\' // npm 安装ts-loader\n            }\n          ]\n        }\n    }\n\ntsconfig.json\n\n    {\n      "compilerOptions":{\n        "module":"commonjs",\n        "target":"es5",\n      },\n      "exclude":["./node_modules"]\n    }\n')])])])])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("7、css的编译和处理")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("如何引入css文件")]),e._v(" "),s("p",[e._v("webpack是以js为入口打包的，那么项目的css怎么引入？")]),e._v(" "),s("p",[e._v("css可以通过js文件引入，但必须使用相应的loader")]),e._v(" "),s("ol",[s("li",[e._v("css-loader，让css可以被js正确的引入")]),e._v(" "),s("li",[e._v("style-loader，让css被引入后可以被正确的以一个style标签插入页面")]),e._v(" "),s("li",[e._v("两者的顺序很重要，要先经过css-loader处理，再由style-loader处理。")])])]),e._v(" "),s("li",[s("p",[e._v("style-loader的核心配置")]),e._v(" "),s("ol",[s("li",[e._v("insertAt    style标签插入在哪一块区域")]),e._v(" "),s("li",[e._v("insertInto 插入指定的dom")]),e._v(" "),s("li",[e._v("singleton 是否合并为一个style标签")]),e._v(" "),s("li",[e._v("transform 在浏览器环境下，插入style到页面前，用js对css进行操作")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('      use:[\n          {\n              loader:"style-loader",\n              options:{\n                  insertAt:"top" , // 将style标签插入到head的哪个位置，top表示head头，bottom表示head\t\t\t\t\t\t   // 尾，默认为尾，参数也可以是个对象，\n                  insertAt:{\n                      before:"#mydiv", // 表示将style标签插入到某个div前面,一般不会指定\n                  },\n                  singleton:true, // 将style标签合并，默认为false\n                  transform:"./transform.js", // 在浏览器环境下，插入style到页面前，指定js文件对css进                                         // 行操作，指定的路径为相对路径\n              }\n          }\n      ]\n      // transform.js\n        module.exports=function(css){\n        // 里面可以操作window对象\n        // css是字符串，只能对字符串进行操作；\n        if(window.screen.width<500){\n          css=css.replace(\'red\',\'yellow\');\n        }\n        return css;\n      }\n')])])])]),e._v(" "),s("li",[s("p",[e._v("css-loader的核心配置")]),e._v(" "),s("ol",[s("li",[e._v("minimize 是否压缩css，webpack4.x中移除")]),e._v(" "),s("li",[e._v("module 是否使用css模块化")]),e._v(" "),s("li",[e._v("alias css中的全局别名 webpack4.x 移除")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('  use:[\n      {\n          loader:"style-loader",\n          options:{\n              insertAt:"top" , // 将style标签插入到head的哪个位置，top表示head头，bottom表示head\t\t\t\t\t\t   // 尾，默认为尾，参数也可以是个对象，\n              insertAt:{\n                  before:"#mydiv", // 表示将style标签插入到某个div前面,一般不会指定\n              },\n              singleton:true, // 将style标签合并，默认为false\n              transform:"./transform.js", // 在浏览器环境下，插入style到页面前，指定js文件对css进                                         // 行操作，指定的路径为相对路径\n          },\n          {\n                loader:\'css-loader\',\n                options:{\n                  modules:{\n                  module:true, // 开启css模块化\n                  localIdentName:\'[path][name]_[local]_[hash:4]\' // 定制class类名，设置css-modules模式下local类名的命名\n                  }                    \n                } \n              },\n      }\n  ]\n  \n')])])])]),e._v(" "),s("li",[s("p",[e._v("css module 的使用")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("          1. :global(.class|#id) 声明全局规则，凡是这样声明的class，都不会被编译成hash字符串\n          :global(#box) {\n          \n              }\n          :global{\n                  #box{\n          \n                  }\n              }\n          2. :local(.class) 在局部作用域中声明选择器，建议使用驼峰式命名，这样可以更容易在 js 中引用\n          3. composes: className 用来组合其他类\n          :local(.className) {\n              // ...\n          }\n          :local(.cn) {\n              composes: className; // 组合局部作用域的规则\n              // composes: className from 'xxx.css'; // 组合其他文件中的规则\n          }\n          // js 中引用\n          import styles from 'index.less';\n          \n          export default const Index = () => (\n              <div className={styles.appContainer}>\n                  <div className={styles.appBody}></div>\n              </div>\n          );\n          开启了css-module ，必须通过js来控制css，也就是要在js中引入css，通过向js对象一样引用css样式\n")])])]),s("ul",[s("li",[s("p",[e._v("less，sass 预处理语言")]),e._v(" "),s("ol",[s("li",[e._v("less、sass是css预处理语言，用来帮助我们更方便的写css。更方便团队合作")]),e._v(" "),s("li",[e._v("less、sass浏览器无法直接识别，需要编译成css才能被识别。所以我们写的less、sass的文件都需要编译")]),e._v(" "),s("li",[e._v("less、sass编译所需loader")])]),e._v(" "),s("p",[e._v("less所需要的loader\nless\nless-loader")]),e._v(" "),s("p",[e._v("sass所需要的loader\nsass-loader\nnode-sass")])]),e._v(" "),s("li",[s("p",[e._v("css提取：如何把css提取为单独的文件")]),e._v(" "),s("ol",[s("li",[e._v("安装对应的插件：extract-text-webpack-plugin")]),e._v(" "),s("li",[e._v("改造loader处的写法：把use改为使用extract-text-webpack-plugin")]),e._v(" "),s("li",[e._v("在plugin处添加：把extract-text-webpack-plugin加入到plugin里")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('  版本差异：在webpack3.x中：直接安装npm i extract-text-webpack-plugin webpack --save-dev\n  \t\t在webpack4.x中：npm i extract-text-webpack-plugin@next webpack --save-dev\n  \t\t必须在局部安装webpack，因为该插件是用局部的webpack打包的\n  \t\t\n  \t\t\n  var extractTextCss=require(\'extract-text-webpack-plugin\');\n  module.exports= {\n  \tentry:{\n  \t app:"./app.js",\n  \t},\n  \toutput:{\n  \t\tpath:__dirname+"/src/dist",\n  \t\tfilename:"./[name].bundle.js"\n  \t},\n   \tresolve:{\n       alias: {\n         a2:"./js/app2.js",\n       }\n   \t},\n  \tmodule:{\n  \t\trules: [\n       {\n         test:/\\.less$/,\n         use:extractTextCss.extract({\n         // fallback的值是style-loader的配置\n          fallback:{\n             loader:\'style-loader\',\n             options:{\n              //insertInto:"#mydiv",\n              singleton:true,\n              transform:"./transform.js"\n             }\n           },\n           // use属性的值是css-loader等其它相关配置\n            use:[     \n             {\n               loader:\'css-loader\',\n               options:{\n                 modules:{\n                  localIdentName:\'[path][name]_[local]_[hash:4]\'\n                 }                    \n               } \n             },\n             // 使用postcss-loader 需安装的loader\n             // cnpm install postcss postcss-loader autoprefixer postcss-cssnext --save-dev\n             // 引入的顺序在css-loader之前，在其它预处理语言之后\n             {\n               loader:\'postcss-loader\', \n               options:{\n                ident:\'postcss\', // 给谁使用的\n                // postcss 使用的插件\n                plugins:[\n                 require(\'autoprefixer\')({\n                     "overrideBrowserslist":[">1%","last 2 versions"] // 指定浏览器版本，否则不生效\n                 }),\n                 require(\'postcss-cssnext\')() // 兼容下一代css语法\n                ]\n               }\n             },\n             {\n              loader:\'less-loader\'\n             }        \n            ]         \n         })\n       }\n  \t\t]\n  \t},\n    plugins:[\n     new extractTextCss({\n      filename:\'[name].min.css\'\n     })\n    ]\n  }\n  \n  // 在package.json 中统一配置指定autoprefixer，babel-loader的浏览器版本\n  {\n    "name": "webpack-3.1.6",\n    "version": "1.0.0",\n    "description": "",\n    "main": "app.js",\n    "scripts": {\n      "test": "echo \\"Error: no test specified\\" && exit 1"\n    },\n    "keywords": [],\n    "author": "",\n    "license": "ISC",\n    "devDependencies": {\n      "css-loader": "^3.0.0",\n      "postcss-cssnext": "^3.1.0",\n      "style-loader": "^0.23.1"\n    },\n    "dependencies": {\n      "autoprefixer": "^9.6.1",\n      "extract-text-webpack-plugin": "^4.0.0-beta.0",\n      "less": "^3.9.0",\n      "less-loader": "^5.0.0",\n      "postcss": "^7.0.17",\n      "postcss-loader": "^3.0.0",\n      "webpack": "^4.35.3"\n    },\n    // 在package.json 中统一配置指定autoprefixer，babel-loader的浏览器版本,此处配置了之后，就不用在webpack.config.js 中单独配置了\n    "browserslist": [\n      ">1%",\n      "last 2 versions"\n    ]\n  }\n')])])])])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("8、html的生成")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("需要用到的plugin")]),e._v(" "),s("p",[e._v("cnpm install html-webpack-plugin --save-dev")])]),e._v(" "),s("li",[s("p",[e._v("相关配置")]),e._v(" "),s("p",[e._v("filename：打包生成后html文件的名字，必须的，相对路径")]),e._v(" "),s("p",[e._v("template：指定一个html文件为模版，必须的，相对路径")]),e._v(" "),s("p",[e._v("minify：压缩html")]),e._v(" "),s("p",[e._v("inject：是否把js，css文件插入到html，插入到哪")]),e._v(" "),s("p",[e._v("chunks：多入口时，指定引入chunks,不配置该属性，则表示全部引入")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  var extractTextCss=require('extract-text-webpack-plugin'); // css代码分离\n  var htmlWebpackPlugin=require('html-webpack-plugin'); // 生成html文件\n  module.exports= {\n   ...\n  \t// webpack引入的插件\n    plugins:[\n     new extractTextCss({\n      filename:'[name].min.css'\n     }),\n     new htmlWebpackPlugin({\n     \tfilename:\"index.html\", // 必须，指定输入的html文字\n     \ttemplate:\"./index.html\",// 必须,指定html模版\n      chunks:['app'] // 指定引入的入口文件打包之后的文件\n     })\n    ]\n  }\n")])])]),s("hr")])]),e._v(" "),s("p",[e._v("9、cross-env：运行跨平台设置和使用环境变量的脚本")]),e._v(" "),s("p",[e._v("要理解 process.env.NODE_ENV 就必须要了解 process，process 是 node 的全局变量，并且 process 有 env 这个属性 ,可以通过cross-env 设置运行跨平台设置和使用环境变量的脚本。")]),e._v(" "),s("p",[e._v("作用：当我们使用 NODE_ENV = production 来设置环境变量的时候，大多数windows命令会提示将会阻塞或者异常，或者，windows不支持NODE_ENV=development的这样的设置方式，会报错。因此 cross-env 出现了。我们就可以使用 cross-env命令，这样我们就不必担心平台设置或使用环境变量了。也就是说 cross-env 能够提供一个设置环境变量的scripts，这样我们就能够以unix方式设置环境变量，然而在windows上也能够兼容的。")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("安装：npm i cross-env --save-dev")])]),e._v(" "),s("li",[s("p",[e._v("在package.json中的script命令如下设置")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('  "scripts": {\n      "pre": "yarn --registry https://registry.npm.taobao.org || npm install --registry https://registry.npm.taobao.org ",\n      "dev": "cross-env NODE_ENV=development webpack --config webpack.dev.config.js",\n      "build": "cross-env NODE_ENV=production webpack --config webpack.dev.config.js",\n      "lint": "vue-cli-service lint"\n    },\n')])])]),s("p",[e._v("通过这样设置 就可以在项目中的任何文件中使用")]),e._v(" "),s("p",[e._v("let env = process.env.NODE_ENV")])])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("10、webpack的环境")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("为什么要区分环境")]),e._v(" "),s("p",[e._v("在不同的场景下可能需要不同的配置，使用不同的功能，所以要区分环境。")]),e._v(" "),s("p",[e._v("比如：")]),e._v(" "),s("p",[e._v("开发模式：会额外用到一些调试功能，比如webpack-dev-server，但是为了加快调试速度，可能不会用上压缩，tree-shaking之类的功能")]),e._v(" "),s("p",[e._v("生产模式：为了减少文件体积，会使用压缩，tree-shaing等功能，但是不要如webpack-dev-server或者eslint这样的调试工具")])]),e._v(" "),s("li",[s("p",[e._v("具体列举一下生产环境和开发环境的不同")]),e._v(" "),s("p",[s("em",[s("strong",[e._v("生产环境")])])]),e._v(" "),s("p",[e._v("去除无用代码")]),e._v(" "),s("p",[e._v("图片压缩，转码base64，雪碧图")]),e._v(" "),s("p",[e._v("提取公用代码")]),e._v(" "),s("p",[s("em",[s("strong",[e._v("开发环境")])])]),e._v(" "),s("p",[e._v("webpack-dev-server  配置代理")]),e._v(" "),s("p",[e._v("source-map")]),e._v(" "),s("p",[e._v("代码风格检查")]),e._v(" "),s("p",[s("em",[s("strong",[e._v("如何告诉webpack当前环境")])])]),e._v(" "),s("p",[e._v("命令：webpack --env  ｛name｝")]),e._v(" "),s("ol",[s("li",[e._v("把开发环境和生产环境的共同配置（公共代码）提取出来，命名为webpack.common.js")]),e._v(" "),s("li",[e._v("开发环境单独配置webpack代码，并且引入webpack的共同配置，命名为webpack.dev.js")]),e._v(" "),s("li",[e._v("生产环境单独配置 webpack代码，并且引入webpack的共同配置，命名为webpack.pro.js")]),e._v(" "),s("li",[e._v("如果是开发环境，使用命令 webpack --config  webpack.dev.js --env dev，进行开发调试")]),e._v(" "),s("li",[e._v("如果是生产环境，使用命令webpack --config  webpack.pro.js --env pro，进行打包")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    // webpack.common.js 公共环境的配置文件：生产环境和开发环境都需要的配置提取出来\n    const webpack=require('webpack');\n    const extractTextCss=require('extract-text-webpack-plugin'); // 提取css代码\n    const dev=require('./webpack.dev.js');  // 引入开发环境的特殊配置\n    const pro=require('./webpack.pro.js');  // 引入生产环境的特殊配置\n    const merge=require('webpack-merge');  // webpack-merge做了两件事：它允许连接数组并合并对象，而不是\t\t\t\t\t\t\t\t\t //\t覆盖组合。把不同的环境下的webpack配置和公共环境的配置文件                                        // 合并到一起\n    module.exports=env=>{\n      var postPlugins=[require('autoprefixer')(), require('postcss-cssnext')()];\n      postPlugins.concat(env==='production'?[require('postcss-sprites')({\n                                                spritePath: 'dist/sprite',\n                                                retina: true\n                                            })]:[])\n      //配置对象\n      var common={\n        entry:'./app.js',\n        output:{\n          filename:'bundle.js'\n        },\n        module:{\n            rules: [  \n              //js处理\n              {\n                test:/\\.js$/,\n                use:\n                  {\n                    loader:'babel-loader',\n                  }\n              },\n              //css处理\n              {\n                test:/\\.less$/,\n                use:extractTextCss.extract({\n                  fallback:{\n                    loader:'style-loader',\n                    options:{\n                      //insertInto:\"#mydiv\",\n                      singleton:true,\n                      //transform:\"./transform.js\"\n                    }\n                  },\n                    use:[       \n                    {\n                      loader:'css-loader',\n                      options:{\n                        modules:{\n                          localIdentName:'[path][name]_[local]_[hash:4]'\n                        }                    \n                      } \n                    },\n                    {\n                      loader:'postcss-loader',\n                      options:{\n                        ident:'postcss',\n                        plugins:postPlugins\n                      }\n                    },\n                    {\n                      loader:'less-loader'\n                    }        \n                    ]         \n                })\n              },                   \n            ] \n        },\n        plugins:[\n        //提取额外css文件\n          new extractTextCss({\n            filename:env==='production'?'app.bundle.css':'app.dev.css'\n          })\n        ]\n      };\n      //返回配置对象\n      return merge(common,env==='production'?pro:dev);\n    }\n")])])])]),e._v(" "),s("li",[s("p",[e._v("如何编写不同的配置文件来区分环境")]),e._v(" "),s("ol",[s("li",[e._v("编写一个开发环境下的配置文件")]),e._v(" "),s("li",[e._v("编写一个生产环境下的配置文件")]),e._v(" "),s("li",[e._v("在基础配置引入开发和生产配置")]),e._v(" "),s("li",[e._v("判断env参数，合并对应的配置")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  webpack.dev.js\n  const webpack = require('webpack')\n  module.exports={\n      devtool: 'cheap-module-source-map',\n      devServer: {\n          port: 9001,\n          overlay: true,\n          hot: true,\n          hotOnly: true,\n      },\n      plugins: [\n          new webpack.HotModuleReplacementPlugin(), // 热更新\n          new webpack.NamedModulesPlugin(), // 显示模块的相对路径\n      ]\t\n  }\n\n  webpack.pro.js\n  var webpack = require('webpack')\n  var HtmlWebpackPlugin = require('html-webpack-plugin'); // 生成html\n  module.exports={\n        optimization: {\n          minimize: false\n        },    \n  \tplugins:[\n          new HtmlWebpackPlugin({\n              filename: 'index.html',\n              template: './index.html',\n              minify: {\n                  collapseWhitespace: true // 开启打包\n              },\n              inject:true, // 生成的js，分离的css是否自动插入到html中\n          }),         \t\n  \t]\t\n  }\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  // webpack.common.js 公共环境的配置文件：生产环境和开发环境都需要的配置提取出来\n  const webpack=require('webpack');\n  const extractTextCss=require('extract-text-webpack-plugin'); // 提取css代码\n  const dev=require('./webpack.dev.js');  // 引入开发环境的特殊配置\n  const pro=require('./webpack.pro.js');  // 引入生产环境的特殊配置\n  const merge=require('webpack-merge');  // webpack-merge做了两件事：它允许连接数组并合并对象，而不是\t\t\t\t\t\t\t\t\t //\t覆盖组合。把不同的环境下的webpack配置和公共环境的配置文件                                        // 合并到一起\n  module.exports=env=>{\n    var postPlugins=[require('autoprefixer')(), require('postcss-cssnext')()];\n    // postcss-sprites是postcss的一个插件，处理雪碧图的\n    postPlugins.concat(env==='production'?[require('postcss-sprites')({\n                                              spritePath: 'dist/sprite',\n                                              retina: true\n                                           })]:[])\n    //配置对象\n    var common={\n       entry:'./app.js',\n       output:{\n       \tfilename:'bundle.js'\n       },\n       module:{\n          rules: [  \n             //js处理\n             {\n              test:/\\.js$/,\n              use:\n                {\n                  loader:'babel-loader',\n                }\n             },\n             //css处理\n             {\n               test:/\\.less$/,\n               use:extractTextCss.extract({\n                fallback:{\n                   loader:'style-loader',\n                   options:{\n                    //insertInto:\"#mydiv\",\n                    singleton:true,\n                    //transform:\"./transform.js\"\n                   }\n                 },\n                  use:[       \n                   {\n                     loader:'css-loader',\n                     options:{\n                       modules:{\n                        localIdentName:'[path][name]_[local]_[hash:4]'\n                       }                    \n                     } \n                   },\n                   {\n                     loader:'postcss-loader',\n                     options:{\n                      ident:'postcss',\n                      plugins:postPlugins\n                     }\n                   },\n                   {\n                    loader:'less-loader'\n                   }        \n                  ]         \n               })\n             },                   \n          ] \n       },\n       plugins:[\n       //提取额外css文件\n         new extractTextCss({\n          filename:env==='production'?'app.bundle.css':'app.dev.css'\n         })\n       ]\n    };\n    //返回配置对象\n    return merge(common,env==='production'?pro:dev);\n  }\n")])])])]),e._v(" "),s("li",[s("p",[e._v("为了打包方便，在 package.json 里script命令加入命名")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('    "scripts": {\n      "test": "echo \\"Error: no test specified\\" && exit 1",\n      "build": "webpack --env production --config webpack.common.js",\n      "dev": "webpack-dev-server --env development --config webpack.common.js"\n    },\n    "ke\n')])])])]),e._v(" "),s("li",[s("p",[e._v("webpack版本差异")]),e._v(" "),s("p",[e._v("在webpack4.x中更简单的环境区分")]),e._v(" "),s("p",[e._v("webpack --mode production/development/none")])])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("11、PostCSS详解")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("什么postcss")]),e._v(" "),s("p",[e._v("PostCSS基于js插件去转换css的一个工具。这些插件支持变量，mixin，未来的css语法，在线图片甚至更多。")]),e._v(" "),s("p",[e._v("所以PostCSS只是一个转化css的工具，让我们更好的去写css；")])]),e._v(" "),s("li",[s("p",[e._v("postcss一些常用的插件")]),e._v(" "),s("p",[e._v("autoprefixer是PostCSS最著名的一款插件，用来兼容不同浏览器的css语法，不同浏览器加上css前缀\npostcss-cssnext (内置autoprefixer) 允许你使用未来的css语法，如css4（可以理解为css中的Babel）\npostcss-sprites 自动制作雪碧图，不用手动拼接啦，哈哈哈\ncssnano 压缩css代码(如果你是用webpack的话，css-loader集成了cssnano，你不需要再次引入)\npostcss-hash-classname 把转换后的css文件名附上哈希值\npixrem 将rem转换为px\npostcss-px-to-viewport 将px转换为vh和vw（推荐作为移动端的计量单位，而不是rem）\npostcss-pxtorem 将px转换为rem")])]),e._v(" "),s("li",[s("p",[e._v("postcss webpack配置")]),e._v(" "),s("p",[e._v("详见css的编译和处理")])])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("12、webpack-dev-server 使用")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("什么是webpack-dev-server")]),e._v(" "),s("p",[e._v("项目最终都要打包上线，所以最好能模拟线上环境进行开发调试")]),e._v(" "),s("p",[e._v("webpack-dev-server就是一个让我们可以模拟线上环境进行项目调试的工具")]),e._v(" "),s("p",[e._v("webpack-dev-server 提供的常用功能")]),e._v(" "),s("p",[e._v("路径重定向")]),e._v(" "),s("p",[e._v("浏览器中显示编译错误")]),e._v(" "),s("p",[e._v("接口代理")]),e._v(" "),s("p",[e._v("热更新")])]),e._v(" "),s("li",[s("p",[e._v("使用步骤")]),e._v(" "),s("p",[e._v("安装webpack-dev-server")]),e._v(" "),s("p",[e._v("配置 devServer字段")]),e._v(" "),s("p",[e._v("利用命令行开启服务")])]),e._v(" "),s("li",[s("p",[e._v("devServer常用配置")]),e._v(" "),s("ul",[s("li",[e._v("inline：服务的开启模式")]),e._v(" "),s("li",[e._v("port：代理接口")]),e._v(" "),s("li",[e._v("historyApiFallback：路径重定向")]),e._v(" "),s("li",[e._v("hot：热更新")]),e._v(" "),s("li",[e._v("lazy：懒编译，多入口时，当访问某个入口时，才会对该入口进行编译和服务")]),e._v(" "),s("li",[e._v("overlay：错误遮罩")]),e._v(" "),s("li",[e._v("proxy：代理请求")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(' module:...,\n devServer:{\n         port: 9001, // 代理接口\n         inline:true, // 服务开启模式\n         overlay:true, // 错误遮罩\n         hot:true, // 热更新:在不刷新浏览器的情况下更改代码之后，会在浏览器上面显示更改之后的代码。\n         \t      // webpack-dev-server 热更新这个插件，与extract-text-webpack-plugin这个插件不兼                   // 容,所以在开发环境时，需要关闭这个插件，在生产环境时打开这个插件，同时关闭热更新这                   // 个功能。\n         hotOnly:true, // 表示只用热更新，不用dev-loading刷新页面\n         // 对url路径重定向\n         historyApiFallback:{\n           rewrites:[\n            {\n              from:/^\\/([ -~]+)/,\n              to:function(context){\n                return \'./\'+context.match[1]+\'.html\'\n              }\n            }\n           ]\n         },\n         // 代理请求，对webpack-dev-server进行代理转发\n         proxy:{\n           "/smartSpec":{\n             target:"https://mooc.study.163.com/",\n             changeOrigin:true, // 把http请求中的origin字段进行变换，在浏览器收到后端回复的时候，浏览                                // 器会以为这个是本地请求，而在后端那边会以为是站内的调用。这样，通过这                                // 个简单的配置，就完美的解决了跨域的问题。\n             // 对代理路径的一些规则配置，\n             // 表示匹配到/smartSpec/qd以这个开头的路径，代理到/smartSpec/detail/1202816603.htm这个             // 路径上面\n             pathRewrite:{\n               "^/smartSpec/qd":"/smartSpec/detail/1202816603.htm"\n             },\n             // 对代理请求设置请求头的配置\n             headers:{\n                 \n             }\n           },\n \n         }\n      },\n       plugins: [\n         new HtmlWebpackPlugin({\n             filename: \'index.html\',\n             template: \'./src/index.html\',\n             minify: {\n                 collapseWhitespace: true\n             },\n             inject:true,\n         }),     \n       new extractTextCss({\n         filename:"app.bundle.css",\n         disable:false //热更新:在不刷新浏览器的情况下更改代码之后，会在浏览器上面显示更改之后的代码。\n         \t         // webpack-dev-server 热更新与extract-text-webpack-plugin这个插件不兼                             // 容,所以在开发环境时，需要关闭这个插件，在生产环境时打开这个插件，同时关闭热更                       // 新这个功能。只需要把disable置为false即可。\n       }),\n     ] \n')])])])])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("13、souce-map")]),e._v(" "),s("p",[e._v("为了方便调试，我们需要知道打包后的代码对应源文件的位置。")]),e._v(" "),s("ul",[s("li",[e._v("如果代码有一处错误，无souce-map只能追踪到错误发生在打包后文件的哪个位置，但是打包后的文件就不方便阅读。")]),e._v(" "),s("li",[e._v("有了souce-map，就可以查看错误发生在原模块的哪个地方。")])]),e._v(" "),s("p",[s("em",[s("strong",[e._v("souce-map配置向如下")])])]),e._v(" "),s("p",[s("code",[e._v("devtool:'eval-source-map',")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("14、webpack原理解析")]),e._v(" "),s("ul",[s("li",[e._v("webpack依赖与node的环境与文件操作系统")]),e._v(" "),s("li",[e._v("webpack的打包过程，其实就是利用node去读取文件，然后进行一些字符串处理后，再利用node去写入文件")])]),e._v(" "),s("p",[e._v("loader原理")]),e._v(" "),s("p",[e._v("loader其实是一个方法：接收一个字符串，方法内部处理完后再返回字符串。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('    // resouce表示读取到文件生成的字符串\n    module.exports = function(resouce){\n    \n        var reg = /console.log\\((.+?)\\)/g;\n    \n        return resouce.replace(reg,"");\n    \n    }\n')])])]),s("hr"),e._v(" "),s("p",[e._v("15、webpack等资源的处理")]),e._v(" "),s("p",[s("em",[s("strong",[e._v("需要用到哪些loader")])])]),e._v(" "),s("ul",[s("li",[e._v("file-loader：引入各种资源的loader，图片，视频，字体图标等资源")]),e._v(" "),s("li",[e._v("url-loader：url-loader是file-loader的二次封装，一般用url-loader来替代file-loader，还增加了一些其它功能；比如把图片转换成base64编码")]),e._v(" "),s("li",[e._v("img-loader：用来用来优化图片的，主要用来压缩图片")]),e._v(" "),s("li",[e._v("html-loader：处理html里面引入各种资源的loader，默认只会处理某些标签的src属性处理")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("      {\n        test: /\\.(png|jpg|jgeg|gif)$/,\n\n        use: [\n          // {\n          //   loader: 'file-loader',\n          //   options: {\n          //     //默认是[hash].[ext]\n          //     name: '[name].[hash:4].[ext]', // name为图片原始文件名， ext为后缀名\n          //     outputPath: \"assets/img\", // 指定文件打包输出的路径；css里自动会根据打包的路径自动更改为打包后的路径\n          //     publicPath: \"assets/img\", // 指定打包后的css路径加的路径前缀\n          //   }\n          // },\n          // url-loader 是file-loader的二次封装，一般用来代替file-loader\n          {\n            loader: 'url-loader',\n            options: {\n              //默认是[hash].[ext]\n              name: '[name].[hash:4].[ext]', // name为图片原始文件名， ext为后缀名\n              outputPath: \"assets/img\", // 指定文件打包输出的路径；css里自动会根据打包的路径自动更改为打包后的路径\n              publicPath: \"assets/img\", // 指定打包后的css路径加的路径前缀\n              limit: 5000 // 当资源小于5kb时，会把资源转换成base64编码\n            }\n          },\n          // img-loader 用来优化图片的loader，本身不具有功能，通postcss一样，起作用的是其他的插件，相当于一个插槽\n          {\n            loader: 'img-loader',\n            options: {\n              plugins: [\n                // 压缩png\n                require('imagemin-pngquant')({ \n                  speed: 2  //1-11\n                }),\n                // 压缩jpg\n                require('imagemin-mozjpeg')({\n                  quality: 80  //1-100\n                }),\n                // 压缩gif\n                require('imagemin-gifsicle')({\n                  optimizationLevel: 1   //1,2,3\n                })\n              ]\n            }\n          },\n        ]\n      },\n      // html-loader 处理html里面引入各种资源的loader\n      // 不引入html-loader，可以通过webpack自带的处理方式，模版语法 <img src=\"${require('./assets/img/img4.jpg')}\"/>\n      // html-loader 默认只会处理某些标签的src属性处理\n      {\n        test: /\\.html$/,\n        use: {\n          loader: 'html-loader',\n          options: {\n            attrs: [\"img:data-src\"]\n          }\n        }\n      },\n      {\n        test: /\\.etf$/,\n        use: {\n          loader: 'html-loader',\n          options: {\n            attrs: [\"img:data-src\"]\n          }\n        }\n      }\n    ]\n  },\n")])])]),s("p",[s("em",[s("strong",[e._v("雪碧图的合成")])])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("postcss-sprites")]),e._v(" "),s("th",[e._v("webpack-spritesmith")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("属于postcss插件，会自动把css文件中引入的背景图合成雪碧图，并修改css文件")]),e._v(" "),s("td",[e._v("属于一个独立的插件，会按照指定的路径指定的图片类型，生成一个雪碧图，和一个雪碧图相关的css，不会修改css")])])])]),e._v(" "),s("pre",[s("code",[e._v("```\n  var extractTextCss = require('extract-text-webpack-plugin');\n  var htmlWebpackPlugin = require('html-webpack-plugin');\n  const webpackSpriteSmith = require('webpack-spritesmith') // webpack自带的雪碧图插件\n  const path = require('path');\n  module.exports = {\n    ...\n    module: {\n      rules: [\n        {\n          test: /\\.css$/,\n          use: extractTextCss.extract({\n            fallback: {\n              loader: 'style-loader',\n              options: {\n                //insertInto:\"#mydiv\",\n                //transform:\"./transform.js\"\n              }\n            },\n            use: [\n              {\n                loader: 'css-loader',\n                options: {\n                  /*modules:{\n                  localIdentName:'[path][name]_[local]_[hash:4]'\n                  }   */\n                }\n              },\n              // postcss-loader本身不具有功能，起作用的是其他的插件，相当于一个插槽\n              // postcss-loader 放在所有css的loader之后\n              // 确定，按照原图的大小生成雪碧图，所以会存在定位误差\n              {\n                loader: \"postcss-loader\",\n                options: {\n                  plugins: [\n                    /* require('postcss-sprites')({\n                      spirtePath:\"./dist/assets/sprite\" 指定生成的雪碧图存放的位置\n                    })*/\n                  ]\n                }\n              }\n            ]\n          })\n        },\n      ...\n    },\n    plugins: [\n      \n      // webpack自带雪碧图的插件配置\n      new webpackSpriteSmith({\n        src: {\n          //图片来源文件夹\n          cwd: path.join(__dirname, \"src/assets/img\"),\n          //处理什么图片\n          glob: \"*.jpg\"\n        },\n        target: {\n          //打包到哪\n          image: path.join(__dirname, 'dist/sprites/sprite.png'),\n          css: path.join(__dirname, 'dist/sprites/sprite.css'),\n        },\n        apiOptions: {\n          cssImageRef: \"./sprites/sprite.png\"\n        }\n      })\n    ]\n  }\n```\n")])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("16、代码分割，js代码大小控制")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("多页")]),e._v(" "),s("th",[e._v("单页面应用")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("提取公共依赖：把多个页面的用到的依赖打包成一个单独的文件")]),e._v(" "),s("td",[e._v("减少文件体积，拆分应用；把需要异步加载改成异步加载")])])])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("总结起来，打包的一般经验规则")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("多页")]),e._v(" "),s("th",[e._v("单页面应用")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("多个入口，多个输出")]),e._v(" "),s("td",[e._v("单个入口，单个输出")])]),e._v(" "),s("tr",[s("td",[e._v("主业务代码+公共依赖+第三房包+webpack运行代码")]),e._v(" "),s("td",[e._v("主业务代码+异步模块+第三方包+webpack运行代码")])])])])]),e._v(" "),s("li",[s("p",[e._v("如何进行代码分割")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("webpack3.x")]),e._v(" "),s("th",[e._v("webpack4.x")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("webpack自带插件 commonChunksPlugin")]),e._v(" "),s("td",[e._v("SplitChunksPlugin 配置")])])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  var extractTextCss=require('extract-text-webpack-plugin');\n  var htmlWebpackPlugin=require('html-webpack-plugin');\n  const webpackSpriteSmith=require('webpack-spritesmith');\n  const webpack=require('webpack');\n  const UglifyJs=require('uglifyjs-webpack-plugin');\n  const { CleanWebpackPlugin } = require('clean-webpack-plugin');\n  const path=require('path');\n  module.exports= {\n    mode:'production', // webpack4.x之后，把mode设置成production，打包时候会自动开启代码压缩和tree-shaking\n  \tentry:{\n  \t app:\"./src/app.js\",\n  \t},\n  \toutput:{\n  \t\tpath:__dirname+\"/dist\",\n  \t\tfilename:\"./[name].bundle.js\",\n    },\n  \n    // optimization属性是webpack4.x里控制代码分割，代码压缩的配置项\n    optimization:{\n      // 控制代码压缩\n      minimize:true,\n      // webpack4.x 通过配置splitChunks来实现代码分割\n      splitChunks:{\n        name:true,\n        chunks:\"all\", // 有三个值：initial(只对入口文件进行分割)、all（对所有文件进行分割）、async（对异步文件进行分割）\n        minSize:0, // 对大小小于多少的进行提取，代码分割，设置为0表示不管模块大小都进行分割\n        // 对模块的自定义提取\n        cacheGroups:{\n          mode1:{\n            test:/mode1/, //正则表达式，匹配文件名为mode1 的模块\n          },\n          vendor:{\n            test:/([\\\\/node_modules[\\\\/])/, // 表示提取node_modules里的第三方模块\n            name:\"vendor\", // 指定提取出来的名字为vendor\n          },\n        }\n      },\n      // 提出webpack的运行代码\n      runtimeChunk:true\n    },\n  \tmodule:{\n  \t\trules: [    \n       {\n         test:/\\.css$/,\n         use:extractTextCss.extract({\n          fallback:{\n             loader:'style-loader',\n             options:{\n              //insertInto:\"#mydiv\",\n              //transform:\"./transform.js\"\n             }\n           },\n          use:[\n           {\n             loader:'css-loader',\n             options:{\n               /*modules:{\n                localIdentName:'[path][name]_[local]_[hash:4]'\n               }   */                 \n             } \n           },\n          ]\n         })\n       },\n       {\n        test:/\\.(png|jpg|jgeg|gif)$/,\n        use:[\n          {\n            loader:'url-loader',\n            options:{\n              //默认是[hash].[ext]\n              name:'[name].[hash:4].[ext]',\n              outputPath:\"assets/img\",\n              publicPath:\"assets/img\",\n              limit:5000\n            }\n          },\n          {\n            loader:'img-loader',\n            options:{\n              plugins:[\n                require('imagemin-pngquant')({\n                  speed:2//1-11\n                }),\n                require('imagemin-mozjpeg')({\n                  quality:80//1-100\n                }),\n                require('imagemin-gifsicle')({\n                  optimizationLevel:1//1,2,3\n                })\n              ]\n            }\n          },\n        ]\n       },\n      {\n        test:/\\.html$/,\n        use:{\n          loader:'html-loader',\n          options:{\n            attrs:[\"img:data-src\"]\n          }\n        }\n      } \n  \t\t]\n  \t},\n    plugins:[\n     new extractTextCss({\n      filename:'[name].min.css'\n     }),\n     new htmlWebpackPlugin({\n     \tfilename:\"index.html\",\n     \ttemplate:\"./src/index.html\",\n     }),\n     // 清楚之前的打包dist文件\n     new CleanWebpackPlugin(),\n  \n  \n     // webpack3.x 代码分割的配置\n     // 拆分 第三房包代码\n     /*new webpack.optimize.CommonsChunksPlugin({\n       name:'vendor',\n       minChunks:'infinity' // 表示无论出现多少次都会拆分\n     }),\n     // 拆分 webpack运行代码\n     new webpack.optimize.CommonsChunksPlugin({\n       name:'manifest',\n       minChunks:'infinity'\n     }),\n  \n     // 拆分业务代码\n     new webpack.optimize.CommonsChunksPlugin({\n       name:'app.js',\n       minChunks:2\n     }),*/   \n     //new webpack.optimize.UglifyJsPlugin();\n    ]\n  }\n")])])])]),e._v(" "),s("li",[s("p",[e._v("代码体积控制")]),e._v(" "),s("p",[s("em",[s("strong",[e._v("代码压缩")])])]),e._v(" "),s("p",[s("em",[s("strong",[e._v("tree-shaking")])])]),e._v(" "),s("p",[e._v("tree-shaking对export default 出的代码不友好，不能tree-shaking")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  module.exports=function(){\n  \tconsole.log(\"a\");\n  \tfunction a(){\n  \n  \t}\n  \tfunction b(){\n  \t\t\n  \t}\n  }\n  // 这种export 的代码不能tree-shaking\n\n  // 对这种代码 比较友好\n  export const a=function(){\n  \tconsole.log('i am a');\n  }\n  export const b=function(){\n  \tconsole.log('i am b');\n  }\n")])])])])])])}),[],!1,null,null,null);n.default=a.exports}}]);