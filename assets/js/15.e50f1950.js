(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{288:function(e,n,t){"use strict";t.r(n);var a=t(3),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"react-函数式组件性能优化指南"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-函数式组件性能优化指南"}},[e._v("#")]),e._v(" React 函数式组件性能优化指南")]),e._v(" "),t("h4",{attrs:{id:"react-性能优化思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-性能优化思路"}},[e._v("#")]),e._v(" React 性能优化思路")]),e._v(" "),t("p",[e._v("我觉得 React 性能优化的理念的主要方向就是这两个：")]),e._v(" "),t("ul",[t("li",[e._v("减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconction(简单的可以理解为 diff)，如果不 render，就不会 reconction。")]),e._v(" "),t("li",[e._v("减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。")])]),e._v(" "),t("p",[e._v("在使用类组件的时候，使用的 React 优化 API 主要是：shouldComponentUpdate和 PureComponent，这两个 API 所提供的解决思路都是为了减少重新 render 的次数，主要是减少父组件更新而子组件也更新的情况，虽然也可以在 state 更新的时候阻止当前组件渲染，如果要这么做的话，证明你这个属性不适合作为 state，而应该作为静态属性或者放在 class 外面作为一个简单的变量 。")]),e._v(" "),t("p",[e._v("但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？")]),e._v(" "),t("hr"),e._v(" "),t("h5",{attrs:{id:"react-memo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-memo"}},[e._v("#")]),e._v(" React.memo")]),e._v(" "),t("p",[e._v("首先要介绍的就是 React.memo，这个 API 可以说是对标类组件里面的 PureComponent，这是可以减少重新 render 的次数的。")]),e._v(" "),t("p",[e._v("探讨可能产生的性能问题")]),e._v(" "),t("p",[e._v("当函数式组件在父组件重新render时，函数式组件会重新从头开始执行函数调用，不管props有无变化。我们需要的是，父组件重新render时，当props无变化时，函数式组件不重新渲染。")]),e._v(" "),t("p",[e._v("那么我们怎么才能做到props无变化时，函数式自组件不渲染呢？\n答案就是用 React.memo 在给定相同 props 的情况下渲染相同的结果，并且通过记忆组件渲染结果的方式来提高组件的性能表现。")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("React.memo 的基础用法")])])]),e._v(" "),t("p",[e._v("把声明的组件通过React.memo包一层就好了，React.memo其实是一个高阶函数，传递一个组件进去，返回一个可以记忆的组件。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Component(props) {\n   /* 使用 props 渲染 */\n}\nconst MyComponent = React.memo(Component);\n")])])]),t("p",[e._v("举个栗子")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import React from "react";\n\nfunction Child(props) {\n  console.log(props.name)\n  return <h1>{props.name}</h1>\n}\n\nexport default React.memo(Child)\n')])])]),t("p",[e._v("通过 React.memo 包裹的组件在 props 不变的情况下，这个被包裹的组件是不会重新渲染的，也就是说上面那个例子，当父组件重新render时，但props无变化时， Child 组件不会重新渲染（表现出来的效果就是 Child 里面的 log 不会在控制台打印出来），会直接复用最近一次渲染的结果。")]),e._v(" "),t("p",[e._v("这个效果基本跟类组件里面的 PureComponent效果极其类似，只是前者用于函数组件，后者用于类组件。")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("React.memo 高级用法")])])]),e._v(" "),t("p",[e._v("默认情况下其只会对 props 的复杂对象做浅层对比(浅层对比就是只会对比前后两次 props 对象引用是否相同，不会对比对象里面的内容是否相同)，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function MyComponent(props) {\n  /* 使用 props 渲染 */\n}\nfunction areEqual(prevProps, nextProps) {\n  /*\n  如果把 nextProps 传入 render 方法的返回结果与\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\n  否则返回 false\n  也就时说：如果函数返回 true，就会跳过更新。\n  */\n}\nexport default React.memo(MyComponent, areEqual);\n")])])]),t("hr"),e._v(" "),t("p",[t("em",[t("strong",[e._v("useCallback")])])]),e._v(" "),t("p",[e._v("先看下面的栗子")]),e._v(" "),t("p",[e._v("父组件index.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// index.js\nimport React, { useState } from "react";\nimport ReactDOM from "react-dom";\nimport Child from "./child";\n\nfunction App() {\n  const [title, setTitle] = useState("这是一个 title");\n  const [subtitle, setSubtitle] = useState("我是一个副标题");\n\n  const callback = () => {\n    setTitle("标题改变了");\n  };\n  return (\n    <div className="App">\n      <h1>{title}</h1>\n      <h2>{subtitle}</h2>\n      <button onClick={() => setSubtitle("副标题改变了")}>改副标题</button>\n      <Child onClick={callback} name="桃桃" />\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById("root");\nReactDOM.render(<App />, rootElement);\n')])])]),t("p",[e._v("子组件 child.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import React from "react";\n\nfunction Child(props) {\n  console.log(props);\n  return (\n    <>\n      <button onClick={props.onClick}>改标题</button>\n      <h1>{props.name}</h1>\n    </>\n  );\n}\n\nexport default React.memo(Child);\n')])])]),t("p",[e._v("性能问题")]),e._v(" "),t("p",[e._v("当我点击改副标题这个 button 之后，副标题会变为「副标题改变了」，并且控制台会再次打印出桃桃，这就证明了子组件又重新渲染了，但是子组件没有任何变化，那么这次 Child 组件的重新渲染就是多余的，那么如何避免掉这个多余的渲染呢？")]),e._v(" "),t("p",[e._v("找原因")]),e._v(" "),t("p",[e._v("我们在解决问题的之前，首先要知道这个问题是什么原因导致的？")]),e._v(" "),t("p",[e._v("咱们来分析，一个组件重新重新渲染，一般三种情况：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("要么是组件自己的状态改变")])]),e._v(" "),t("li",[t("p",[e._v("要么是父组件重新渲染，导致子组件重新渲染，但是父组件的 props 没有改版")])]),e._v(" "),t("li",[t("p",[e._v("要么是父组件重新渲染，导致子组件重新渲染，但是父组件传递的 props 改变")])])]),e._v(" "),t("p",[e._v("接下来用排除法查出是什么原因导致的：")]),e._v(" "),t("p",[e._v("第一种很明显就排除了，当点击改副标题 的时候并没有去改变 Child 组件的状态；")]),e._v(" "),t("p",[e._v("第二种情况好好想一下，是不是就是在介绍 React.memo 的时候情况，父组件重新渲染了，父组件传递给子组件的 props 没有改变，但是子组件重新渲染了，我们这个时候用 React.memo 来解决了这个问题，所以这种情况也排除。")]),e._v(" "),t("p",[e._v("那么就是第三种情况了，当父组件重新渲染的时候，传递给子组件的 props 发生了改变，再看传递给 Child 组件的就两个属性，一个是 name，一个是 onClick ，name 是传递的常量，不会变，变的就是 onClick 了，为什么传递给 onClick 的 callback 函数会发生改变呢？在文章的开头就已经说过了，"),t("strong",[t("font",{attrs:{color:"red"}},[e._v("在函数式组件里每次重新渲染，函数组件都会重头开始重新执行，那么这两次创建的 callback 函数肯定发生了改变，所以导致了子组件重新渲染。")])],1)]),e._v(" "),t("p",[t("strong",[e._v("如何解决")])]),e._v(" "),t("p",[e._v("找到问题的原因了，那么解决办法就是在函数没有改变的时候，重新渲染的时候保持两个函数的引用一致，这个时候就要用到 useCallback 这个 API 了。")]),e._v(" "),t("p",[e._v("useCallback 使用方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const callback = () => {\n  doSomething(a, b);\n}\n\nconst memoizedCallback = useCallback(callback, [a, b])\n")])])]),t("p",[e._v("把函数以及依赖项作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，这个 memoizedCallback 只有在依赖项有变化的时候才会更新。")]),e._v(" "),t("p",[e._v("那么可以将 index.js 修改为这样：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// index.js\nimport React, { useState, useCallback } from "react";\nimport ReactDOM from "react-dom";\nimport Child from "./child";\n\nfunction App() {\n  const [title, setTitle] = useState("这是一个 title");\n  const [subtitle, setSubtitle] = useState("我是一个副标题");\n\n  const callback = () => {\n    setTitle("标题改变了");\n  };\n\n  // 通过 useCallback 进行记忆 callback，并将记忆的 callback 传递给 Child\n  const memoizedCallback = useCallback(callback, [])\n\n  return (\n    <div className="App">\n      <h1>{title}</h1>\n      <h2>{subtitle}</h2>\n      <button onClick={() => setSubtitle("副标题改变了")}>改副标题</button>\n      <Child onClick={memoizedCallback} name="桃桃" />\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById("root");\nReactDOM.render(<App />, rootElement);\n\n')])])]),t("p",[t("strong",[t("font",{attrs:{color:"red"}},[e._v("如果我们的 callback 传递了参数，当参数变化的时候需要让它重新添加一个缓存，可以将参数放在 useCallback 第二个参数的数组中，作为依赖的形式，使用方式跟 useEffect 类似。")])],1)]),e._v(" "),t("hr"),e._v(" "),t("p",[t("em",[t("strong",[e._v("useMemo")])])]),e._v(" "),t("p",[e._v("在文章的开头就已经介绍了，React 的性能优化方向主要是两个：一个是减少重新 render 的次数(或者说减少不必要的渲染)，另一个是减少计算的量。")]),e._v(" "),t("p",[e._v("前面介绍的 React.memo 和 useCallback 都是为了减少重新 render 的次数。对于如何减少计算的量，就是 useMemo 来做的，接下来我们看例子。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function App() {\n  const [num, setNum] = useState(0);\n\n  // 一个非常耗时的一个计算函数\n  // result 最后返回的值是 49995000\n  function expensiveFn() {\n    let result = 0;\n\n    for (let i = 0; i < 10000; i++) {\n      result += i;\n    }\n\n    console.log(result) // 49995000\n    return result;\n  }\n\n  const base = expensiveFn();\n\n  return (\n    <div className="App">\n      <h1>count：{num}</h1>\n      <button onClick={() => setNum(num + base)}>+1</button>\n    </div>\n  );\n}\n')])])]),t("p",[e._v("这个例子功能很简单，就是点击 +1 按钮，然后会将现在的值(num) 与 计算函数 (expensiveFn) 调用后的值相加，然后将和设置给 num 并显示出来，在控制台会输出 49995000。")]),e._v(" "),t("p",[e._v("可能产生性能问题")]),e._v(" "),t("p",[e._v("就算是一个看起来很简单的组件，也有可能产生性能问题，通过这个最简单的例子来看看还有什么值得优化的地方。")]),e._v(" "),t("p",[e._v("首先我们把 expensiveFn 函数当做一个计算量很大的函数(比如你可以把 i 换成 10000000)，然后当我们每次点击 +1 按钮的时候，都会重新渲染组件，而且都会调用 expensiveFn 函数并输出 49995000。由于每次调用 expensiveFn 所返回的值都一样，所以我们可以想办法将计算出来的值缓存起来，每次调用函数直接返回缓存的值，这样就可以做一些性能优化。")]),e._v(" "),t("p",[e._v("useMemo 做计算结果缓存")]),e._v(" "),t("p",[e._v("针对上面产生的问题，就可以用 useMemo 来缓存 expensiveFn 函数执行后的值。")]),e._v(" "),t("p",[e._v("首先介绍一下 useMemo 的基本的使用方法，详细的使用方法可见官网：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function computeExpensiveValue() {\n  // 计算量很大的代码\n  return xxx\n}\n\nconst memoizedValue = useMemo(computeExpensiveValue, [a, b]);\n")])])]),t("p",[e._v("useMemo 的第一个参数就是一个函数，这个函数返回的值会被缓存起来，同时这个值会作为 useMemo 的返回值，第二个参数是一个数组依赖，如果数组里面的值有变化，那么就会重新去执行第一个参数里面的函数，并将函数返回的值缓存起来并作为 useMemo 的返回值 。")]),e._v(" "),t("p",[e._v("了解了 useMemo 的使用方法，然后就可以对上面的例子进行优化，优化代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function App() {\n  const [num, setNum] = useState(0);\n\n  function expensiveFn() {\n    let result = 0;\n    for (let i = 0; i < 10000; i++) {\n      result += i;\n    }\n    console.log(result)\n    return result;\n  }\n\n  const base = useMemo(expensiveFn, []);\n\n  return (\n    <div className="App">\n      <h1>count：{num}</h1>\n      <button onClick={() => setNum(num + base)}>+1</button>\n    </div>\n  );\n}\n')])])]),t("p",[e._v("执行上面的代码，然后现在可以观察无论我们点击 +1多少次，只会输出一次 49995000，这就代表 expensiveFn 只执行了一次，达到了我们想要的效果。")]),e._v(" "),t("p",[e._v("小结")]),e._v(" "),t("p",[e._v("useMemo 的使用场景主要是用来缓存计算量比较大的函数结果，可以避免不必要的重复计算，有过 vue 的使用经历同学可能会觉得跟 Vue 里面的计算属性有异曲同工的作用。")]),e._v(" "),t("p",[e._v("不过另外提醒两点")]),e._v(" "),t("ul",[t("li",[e._v("如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值；")]),e._v(" "),t("li",[e._v("计算量如果很小的计算函数，也可以选择不使用 useMemo，因为这点优化并不会作为性能瓶颈的要点，反而可能使用错误还会引起一些性能问题。")])]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("对于性能瓶颈可能对于小项目遇到的比较少，毕竟计算量小、业务逻辑也不复杂，但是对于大项目，很可能是会遇到性能瓶颈的，"),t("em",[t("strong",[e._v("但是对于性能优化有很多方面：网络、关键路径渲染、打包、图片、缓存等等方面，具体应该去优化哪方面还得自己去排查")])]),e._v("，本文只介绍了性能优化中的冰山一角：运行过程中 React 的优化。")]),e._v(" "),t("ul",[t("li",[e._v("React 的优化方向：减少 render 的次数；减少重复计算。")]),e._v(" "),t("li",[e._v("如何去找到 React 中导致性能问题的方法，见 useCallback 部分。")]),e._v(" "),t("li",[e._v("合理的拆分组件其实也是可以做性能优化的，你这么想，如果你整个页面只有一个大的组件，那么当 props 或者 state 变更之后，需要 reconction 的是整个组件，其实你只是变了一个文字，如果你进行了合理的组件拆分，你就可以控制更小粒度的更新。")])]),e._v(" "),t("p",[t("font",{attrs:{color:"red"}},[e._v("合理拆分组件还有很多其他好处，比如好维护，而且这是学习组件化思想的第一步，合理的拆分组件又是一门艺术了，如果拆分得不合理，就有可能导致状态混乱，多敲代码多思考。")])],1)])}),[],!1,null,null,null);n.default=s.exports}}]);